取火柴的游戏题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。 题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。先解决第一个问题吧。定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则为利己态，用S表示。[定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。证明：    若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态，c = A(1) xor A(2) xor … xor A(n) > 0;把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。    那么我们把x = A(t) xor c,则得到x < A(t).这是因为既然A(t)的第p位与c的第p位同为1,那么x的第p位变为0,而高于p的位并没有改变。所以x < A(t).而    A(1) xor A(2) xor … xor x xor … xor A(n)  = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n)  = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n)  = 0这就是说从A(t)堆中取出 A(t) – x 根火柴后状态就会从S态变为T态。证毕[定理2]：T态，取任何一堆的若干根，都将成为S态。证明：用反证法试试。      若      c = A(1) xor A(2) xor … xor A(i) xor … xor A(n) = 0；      c’ = A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = 0;      则有c xor c’ = A(1) xor A(2) xor … xor A(i) xor … xor A(n) xor A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = A(i) xor A(i’) =0      进而推出A(i) = A(i’)，这与已知矛盾。所以命题得证。[定理 3]：S态，只要方法正确，必赢。   最终胜利即由S态转变为T态，任何一个S态，只要把它变为T态，（由定理1，可以把它变成T态。）对方只能把T态转变为S态(定理2)。这样，所有S态向T态的转变都可以有己方控制，对方只能被动地实现由T态转变为S态。故S态必赢。[定理4]：T态，只要对方法正确，必败。   由定理3易得。 接着来解决第二个问题。定义：若一堆中仅有1根火柴，则被称为孤单堆。若大于1根，则称为充裕堆。定义：T态中，若充裕堆的堆数大于等于2，则称为完全利他态，用T2表示；若充裕堆的堆数等于0，则称为部分利他态，用T0表示。孤单堆的根数异或只会影响二进制的最后一位，但充裕堆会影响高位（非最后一位）。一个充裕堆，高位必有一位不为0，则所有根数异或不为0。故不会是T态。[定理5]：S0态，即仅有奇数个孤单堆，必败。T0态必胜。证明：S0态，其实就是每次只能取一根。每次第奇数根都由己取，第偶数根都由对方取，所以最后一根必己取，败。同理, T0态必胜[定理6]：S1态，只要方法正确，必胜。证明：若此时孤单堆堆数为奇数，把充裕堆取完；否则，取成一根。这样，就变成奇数个孤单堆，由对方取。由定理5，对方必输。己必胜。[定理7]：S2态不可转一次变为T0态。证明：充裕堆数不可能一次由2变为0。得证。[定理8]：S2态可一次转变为T2态。证明：由定理1，S态可转变为T态，态可一次转变为T态，又由定理6，S2态不可转一次变为T0态，所以转变的T态为T2态。 [定理9]：T2态，只能转变为S2态或S1态。 证明：由定理2，T态必然变为S态。由于充裕堆数不可能一次由2变为0，所以此时的S态不可能为S0态。命题得证。[定理10]：S2态，只要方法正确，必胜. 证明：方法如下：1）S2态，就把它变为T2态。（由定理8） 2）对方只能T2转变成S2态或S1态（定理9）    若转变为S2,  转向1）     若转变为S1,  这己必胜。（定理5） [定理11]：T2态必输。 证明：同10。 综上所述，必输态有：  T2,S0           必胜态：    S2,S1,T0. 两题比较： 第一题的全过程其实如下： S2->T2->S2->T2->  ……  ->T2->S1->T0->S0->T0->……->S0->T0(全0) 第二题的全过程其实如下： S2->T2->S2->T2->  ……  ->T2->S1->S0->T0->S0->……->S0->T0(全0) 下划线表示胜利一方的取法。  是否发现了他们的惊人相似之处。 我们不难发现(见加黑部分)，S1态可以转变为S0态（第二题做法），也可以转变为 T0（第一题做法）。哪一方控制了S1态，他即可以有办法使自己得到最后一根（转变为 T0）,也可以使对方得到最后一根（转变为S0）。   所以，抢夺S1是制胜的关键！   为此，始终把T2态让给对方，将使对方处于被动状态，他早晚将把状态变为S1.第二题也可以用SJ定理解决【SJ定理】对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当：（1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；（2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。void solve(int n){    int a,s=0,num=0;    for(int i=0;i<n;i++)    {        scanf("%d",&a);        s=s^a;        if(a > 1)            num++;    }    if(s == 0)    {        if(num == 0)            printf("Yes\n");        else            printf("No\n");    }    else    {        if(num == 0)            printf("No\n");        else            printf("Yes\n");    }}