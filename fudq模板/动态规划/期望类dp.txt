问题描述：
给出这么一个图：有4个点，1和2，2和4，1和3，3和4有边。
有个人在1节点，每一分钟他会沿着边随机走到一个节点或者在原地停留，问他走到4号节点需要平均几分钟？

用Ei(i=1,2,3,4) 表示从i号节点走到4号节点的数学期望值。根据题意对1号节点有
E1=（1/3）*E1+（1/3）*E2+（1/3）*E3+1 ① 表示 他下一分钟可以走到2或者3或在原地1，每个可能概率是1/3 ,注意是下一分钟，故要加上1.
同理我们对节点2，3同样可以列出：
E2=(1/3)*E1+(1/3)*E2+(1/3)*E4+1 ②
E3=(1/3)*E1+(1/3)*E3+(1/3)*E4+1 ③
 
那E4等于多少呢？ 很明显E4=0 ④，因为他就是要到点4。
 
这样上面1234式其实就是组成了一组方程组，解方程组就可得出E1！！用高斯消元，复杂度是O(n^3)
 
从上述例子，我们可总结出如何解决期望类问题：
根据题意，表示出各个状态的期望（上例的Ei，1234）,根据概率公式，列出期望之间的方程，解方程即可。

例：
hdu 4405
题意：飞行棋，掷一次骰子，往前进骰子点数，如果有飞机直接跳到飞机所指位置，当位置大于等于n时表示结束。
题解：
可以根据题意列几个方程，当没有飞机的时候，比如n=3，所列方程为：
dp[0]=1/6*dp[1]+1/6*dp[2]+1/6*dp[3]+1
dp[1]=1/6*dp[2]+1/6*dp[3]+1
dp[2]=1/6*dp[3]+1
dp[3]=0
于是可以总结：如果m=0（没有飞机），则dp[i]=sigma(dp[i+k]/6)+1;(1<=k<=6)，否则dp[i]=dp[f[m]]。

#define N 100010
int n,m,f[N];
double dp[N];

int main()
{
    int a,b;
    while(scanf("%d%d",&n,&m)!=EOF && (n||m))
    {
    	memset(f,-1,sizeof(f));
    	while(m--)
    	{
    		scanf("%d%d",&a,&b);
    		f[a]=b;
    	}
    	dp[n]=0;
    	for(int i=n-1;i>=0;i--)
    	{
    		if(f[i] != -1)
    			dp[i]=dp[f[i]];
    		else
    		{
    			double s=0;
    			for(int j=1;j<=6 && i+j <= n;j++)
    				s+=dp[i+j];
    			dp[i]=s/6.0+1;
    		}
    	}
    	printf("%.4lf\n",dp[0]);
    }
    return 0;
}