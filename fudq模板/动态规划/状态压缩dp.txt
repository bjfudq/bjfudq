例1(hdu4529)：//在8*8的八皇后棋盘上，问最多放n个骑士的方案数，任意两个骑士不受攻击，骑士“日”字走法。//因为骑士走的是“日”字格，所以关联到前两行的状态，这道题棋子个数还有限制，所以可以用f[i][j][p][q]来建立模型，表示第 i 行用了 j 个棋子，第 i 行是 p 状态，第 i - 1 行是 q 状态的最大方案数。//所以复杂度为8*10*(1<<7)*(1<<7)*(1<<7)，如果不剪枝肯定超时，仔细分析下有很多种情况都是不可行的。//用vis[i][p][q]标记第i行p状态，第i-1行q状态是否可行。char c[10][10];int n,f[10][12][130][130];	//f[i][j][p][q] 第i行，j个棋子数，i行p状态，i-1行q状态int huang[10],qinum[130],s[3][10];	//huang记录每行皇后的位置int vis[10][130][130];	//vis[i][p][q], 第i行p状态，第i-1行q状态下，是否可行int Getqizi(int a)	//统计a状态有多少个1{	int tmp=0;	while(a)	{		if(a&1)			tmp++;		a>>=1;	}	return tmp;}void init()	//每种状态多少个1，打表处理{	for(int i=0;i<128;i++)		qinum[i]=Getqizi(i);}void deal(int c,int p,int t)	//第c行的p状态映射到s[t]上{	MEM(s[t]);	int tt=0;	while(p)	{		if(tt == huang[c])	//皇后的位置跳过			s[t][tt++]=-1;		s[t][tt++]=p%2;		p>>=1;	}}int jud1(int t)		//判断相邻两行是否符合条件{	for(int i=0;i<8;i++)		if(s[t][i] == 1)		{			if(i-2 >= 0 && s[t+1][i-2] == 1)				return 0;			if(i+2 < 8 && s[t+1][i+2] == 1)				return 0;		}	return 1;}int jud2()		//判断隔一行是否符合条件{	for(int i=0;i<8;i++)		if(s[0][i] == 1)		{			if(i-1 >= 0 && s[2][i-1] == 1)				return 0;			if(i+1 < 8 && s[2][i+1] == 1)				return 0;		}	return 1;}void solve(){	MEM(f);memset(vis,-1,sizeof(vis));	for(int i=0;i<128;i++)	//预处理第一行	{		f[0][qinum[i]][i][0]++;	}	for(int i=1;i<8;i++)	//行数	{		for(int j=0;j<=n;j++)	//棋子数		{			for(int p=0;p<128;p++)	//枚举第i行的状态			{				int num1=qinum[p];				if(num1 > j)	//如果当前棋子数超出范围则不用继续，下面也一样					continue;				deal(i,p,0);				for(int q=0;q<128;q++)	//枚举第i-1行的状态				{					int num2=qinum[q];					if(num1+num2 > n)						continue;					deal(i-1,q,1);					if(vis[i][p][q] == -1)						vis[i][p][q]=jud1(0);					if(vis[i][p][q] == 0)						continue;					if(i == 1)	//如果是第1行，则不用执行下面的判断					{						f[i][j][p][q]+=f[i-1][j-num1][q][0];						continue;					}					for(int k=0;k<128;k++)	//枚举第i-2行状态					{						int num3=qinum[k];						if(num1+num2+num3 > n)							continue;						deal(i-2,k,2);						if(vis[i-1][q][k] == 0 || !jud2())							continue;						f[i][j][p][q]+=f[i-1][j-num1][q][k];					}				}			}		}	}	LL ans=0;	for(int i=0;i<128;i++)		for(int j=0;j<128;j++)			ans+=f[7][n][i][j];	pf64(ans);}int main(){    int T;    sf(T);    init();    while(T--)    {    	sf(n);    	fr(8) sfs(c[i]);    	//记录每行皇后位置    	for(int i=0;i<8;i++)    	{    		for(int j=0;j<8;j++)    		{    			if(c[i][j] == '*')    			{    				huang[i]=j;    				break;    			}    		}    	}    	solve();    }    return 0;}例2(hdu2167)：//给出n*n的矩阵，每个单元格上一个数，现从矩阵里取数，使得相加和最大，如果一个数被取了，则周围8个方向的数都不能取。3<=n<=15。//典型的状态压缩dp，首先筛选出每一行所有可行状态，最多状态数为1579，当n等于15时。//因为只和上一层状态相关，所以只需要记录当前行的状态，判断相邻两行是否符合条件，巧用位运算来处理。int n,c[16][16];int f[16][1600];	//f[i][j]：第i行前j种状态的最优解int num[16][1600];	//num[i][j]：第i行第j种状态下可取数之和int pnum[16],pz[16][1600];//pnum[i]：i*i的矩阵下的可行状态数，最多有1597种状态，当i等于15时候//pz[i][j]：i*i的矩阵下的第j种可行状态int jud(int a,int tmp)	//判断a状态是否可行{	if(a == 0)		return 1;	int p=a%2;	if(p == 1 && tmp == 1)		return 0;	return jud(a/2,p);}void init1()	//打表所有矩阵(n从3到15)，每一行的所有可行状态{	for(int t=3;t<=15;t++)	{		int tot=1<<t;		pnum[t]=0;		for(int i=0;i<tot;i++)		{			if(!jud(i,0))				continue;			pz[t][pnum[t]++]=i;		}	}}int deal(int h,int a)	//计算第h行，a状态下可取数之和{	int t=0,r=0;	while(a)	{		if(a&1)			r+=c[h][t];		a>>=1;t++;	}	return r;}void init2()	//打表每一行下，每种状态的可取数之和{	for(int i=0;i<n;i++)		for(int j=0;j<pnum[n];j++)			num[i][j]=deal(i,pz[n][j]);}int jud2(int j,int k)	//判断相邻两行，两种状态是否有冲突(巧用位运算){	if(j & k || (j>>1) & k || (j<<1) & k)		return 0;	return 1;}void solve(){	MEM(f);MEM(num);	init2();	for(int i=0;i<n;i++)	{		for(int j=0;j<pnum[n];j++)	//当前状态		{			if(i == 0)	//如果是第一行，则不用看上一行			{				f[0][j]=num[0][j];				continue;			}			for(int k=0;k<pnum[n];k++)	//前一行状态			{				if(!jud2(pz[n][j],pz[n][k]))					continue;				f[i][j]=max(f[i][j],f[i-1][k]+num[i][j]);			}		}	}	int ans=0;	for(int i=0;i<pnum[n];i++)		ans=max(ans,f[n-1][i]);	pf(ans);}int main(){    init1();    char s;    while(sf(c[0][0])!=EOF)    {    	n=1;    	s=getchar();    	while(s != '\n')    	{    		sf(c[0][n++]);    		s=getchar();    	}    	for(int i=1;i<n;i++)    		for(int j=0;j<n;j++)    			sf(c[i][j]);    	solve();    }    return 0;}