题意：给定一个N维(N<=500)矩阵，求其任意一个子矩阵的和。有C(C<=100000)条求和命令，每条命令给出子矩阵的左上角坐标和右下角坐标。

解题思路：
因为C很大，这题如果按着输入的每个矩阵的每个元素相加做的话，肯定超时~
输完二位数组之后，把数组改成这样：每个数代表的是该位置到(1,1)这个位置的矩阵之和，可以有两种改法：
把每行数的和记录在最下一行，然后把每列数的和记录在最右一行（两个n^2）；先记录第一行和第一列，再从（2，2）开始记录（一个n^2）。
第二种方法会用到子块和计算的方法：整个矩阵减去最上面的矩阵，减去最左边的矩阵，加上共同的矩阵。
接着读入坐标的时候，再用子块和计算的方法计算所求矩阵的和。

#include<iostream>
using namespace std;
int a[502][502];

int main()
{
	int T,n,m,i,j,x1,y1,x2,y2,s;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(i=0;i<n;i++)
			for(j=0;j<n;j++)
				scanf("%d",&a[i][j]);
		for(i=0;i<n;i++)
			for(j=1;j<n;j++)
				a[i][j]=a[i][j]+a[i][j-1];
		for(i=1;i<n;i++)
			for(j=0;j<n;j++)
				a[i][j]=a[i][j]+a[i-1][j];
		scanf("%d",&m);
		while(m--)
		{
			scanf("%d,%d,%d,%d",&x1,&y1,&x2,&y2);
			if(y1==1 && x1!=1)
				s=a[x2-1][y2-1]-a[x1-2][y2-1];
			else if(x1==1 && y1!=1)
				s=a[x2-1][y2-1]-a[x2-1][y1-2];
			else if(y1==1 && x1==1)
				s=a[x2-1][y2-1];
			else
				s=a[x2-1][y2-1]-a[x2-1][y1-2]-a[x1-2][y2-1]+a[x1-2][y1-2];
			printf("%d\n",s);
		}
	}
	return 0;
}